# ShaderPulse

ShaderPulse is an experimental GLSL to SPIR-V dialect frontend. It consists of a lexer, a parser, a semantic analyzer and a code generator. The different parts of the compiler are at different stages of completion. The work is based on the [GLSL 4.60.8 specifications](https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf).

## Lexer

The lexer takes in the source code in text format and outputs valid GLSL tokens. It supports all the keyword, punctuator, identifier and literal tokens defined in the specs. There are tests for this component in `test/Lexer/LexerTest`.

## Parser

Takes in the token stream generated by the `Lexer` and outputs an Abstract Syntax Tree. It is top-down recursive descent parser. It supports variable declarations, assignments, function declarations, function calls, unary and binary expressions, constructor expressions, member access (incomplete), structs (incomplete), and arrays (incomplete). There is a lot of work to do on this front to match sepcs.

## Analysis

It supports basic type checking, `break`, `continue`, `case` placement check, function return type checking, `if`/`while`/`do-while` condition type checking. See examples for what is supported in `test/Analysis`. It works based on the visitor pattern, just like code generation. There is a lot of work to do on this front to match sepcs.

## CodeGen

It takes in the AST generated by the parser, and using the visitor pattern visits the AST constructs and generates code for them. Check `CodeGen/MLIRCodeGen.cpp` for constructs that are supported.

The compute shader `/example/compute.glsl` compiles to the following `spir-v mlir` code:

```glsl
layout(local_size_x = 16, local_size_y = 8, local_size_z = 4) in;

layout(binding = 0) buffer InputBuffer {
    float data[];
};

layout(binding = 1) buffer OutputBuffer {
    float result[];
};

void main() {
    uint index = gl_GlobalInvocationID.x;
    result[index] = data[index] * 2.0;
}
```

```mlir
spirv.module Logical GLSL450 requires #spirv.vce<v1.0, [Shader], []> {
  spirv.GlobalVariable @gl_GlobalInvocationID built_in("GlobalInvocationId") : !spirv.ptr<vector<3xui32>, Input>
  spirv.GlobalVariable @gl_WorkGroupID built_in("WorkgroupId") : !spirv.ptr<vector<3xui32>, Input>
  spirv.GlobalVariable @gl_WorkGroupSize built_in("WorkgroupSize") : !spirv.ptr<vector<3xui32>, Input>
  spirv.GlobalVariable @gl_LocalInvocationID built_in("LocalInvocationId") : !spirv.ptr<vector<3xui32>, Input>
  spirv.GlobalVariable @data {binding = 0 : i32} : !spirv.ptr<!spirv.rtarray<f32>, StorageBuffer>
  spirv.GlobalVariable @result {binding = 1 : i32} : !spirv.ptr<!spirv.rtarray<f32>, StorageBuffer>
  spirv.func @main() "None" {
    %gl_GlobalInvocationID_addr = spirv.mlir.addressof @gl_GlobalInvocationID : !spirv.ptr<vector<3xui32>, Input>
    %0 = spirv.Load "Input" %gl_GlobalInvocationID_addr : vector<3xui32>
    %1 = spirv.CompositeExtract %0[0 : i32] : vector<3xui32>
    %2 = spirv.Variable : !spirv.ptr<ui32, Function>
    spirv.Store "Function" %2, %1 : ui32
    %result_addr = spirv.mlir.addressof @result : !spirv.ptr<!spirv.rtarray<f32>, StorageBuffer>
    %3 = spirv.Load "Function" %2 : ui32
    %4 = spirv.AccessChain %result_addr[%3] : !spirv.ptr<!spirv.rtarray<f32>, StorageBuffer>, ui32
    %data_addr = spirv.mlir.addressof @data : !spirv.ptr<!spirv.rtarray<f32>, StorageBuffer>
    %5 = spirv.Load "Function" %2 : ui32
    %6 = spirv.AccessChain %data_addr[%5] : !spirv.ptr<!spirv.rtarray<f32>, StorageBuffer>, ui32
    %cst_f32 = spirv.Constant 2.000000e+00 : f32
    %7 = spirv.Load "StorageBuffer" %6 : f32
    %8 = spirv.FMul %7, %cst_f32 : f32
    spirv.Store "StorageBuffer" %4, %8 : f32
    spirv.Return
  }
  spirv.ExecutionMode @main "LocalSize", 16, 8, 4
  spirv.EntryPoint "GLCompute" @main, @gl_GlobalInvocationID, @result, @data
}
```
