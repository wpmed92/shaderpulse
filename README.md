# ShaderPulse

ShaderPulse is an experimental GLSL to SPIR-V dialect frontend. It consists of a lexer, a parser, a semantic analyzer and a code generator. The different parts of the compiler are at different stages of completion. The work is based on the [GLSL 4.60.8 specifications](https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf).

## Lexer

The lexer takes in the source code in text format and outputs valid GLSL tokens. It supports all the keyword, punctuator, identifier and literal tokens defined in the specs. There are tests for this component in `test/Lexer/LexerTest`.

## Parser

Takes in the token stream generated by the `Lexer` and outputs an Abstract Syntax Tree. It is top-down recursive descent parser. It supports variable declarations, assignments, function declarations, function calls, unary and binary expressions, constructor expressions, member access (incomplete), structs (incomplete), and arrays (incomplete). There is a lot of work to do on this front to match sepcs.

## Analysis

It supports basic type checking, `break`, `continue`, `case` placement check, function return type checking, `if`/`while`/`do-while` condition type checking. See examples for what is supported in `test/Analysis`. It works based on the visitor pattern, just like code generation. There is a lot of work to do on this front to match sepcs.

## CodeGen

It takes in the AST generated by the parser, and using the visitor pattern visits the AST constructs and generates code for them. You can see a working fragment shader in `/example/passthrough_fragment.glsl`. Check `CodeGen/MLIRCodeGen.cpp` for constructs that are supported.

The example provided in `/example` folder compiles to the follow `spir-v mlir` code:

```glsl
layout(location = 0) out vec4 outColor;

// Demonstrate struct handling
struct Color {
  float r;
  float g;
  float b;
  float a;
}

void main() {
  Color color = Color(1.0, 0.0, 0.0, 1.0);
  outColor = vec4(color.r, color.g, color.b, color.a);
  return;
}
```

```mlir
spirv.module Logical GLSL450 requires #spirv.vce<v1.0, [Shader], []> {
  spirv.GlobalVariable @outColor {location = 0 : i32} : !spirv.ptr<vector<4xf32>, Output>
  spirv.func @main() "None" {
    %cst_f32 = spirv.Constant 1.000000e+00 : f32
    %cst_f32_0 = spirv.Constant 0.000000e+00 : f32
    %cst_f32_1 = spirv.Constant 0.000000e+00 : f32
    %cst_f32_2 = spirv.Constant 1.000000e+00 : f32
    %0 = spirv.CompositeConstruct %cst_f32, %cst_f32_0, %cst_f32_1, %cst_f32_2 : (f32, f32, f32, f32) -> !spirv.struct<(f32, f32, f32, f32)>
    %1 = spirv.Variable : !spirv.ptr<!spirv.struct<(f32, f32, f32, f32)>, Function>
    spirv.Store "Function" %1, %0 : !spirv.struct<(f32, f32, f32, f32)>
    %outColor_addr = spirv.mlir.addressof @outColor : !spirv.ptr<vector<4xf32>, Output>
    %2 = spirv.Load "Function" %1 : !spirv.struct<(f32, f32, f32, f32)>
    %cst0_i32 = spirv.Constant 0 : i32
    %3 = spirv.CompositeExtract %2[0 : i32] : !spirv.struct<(f32, f32, f32, f32)>
    %4 = spirv.Load "Function" %1 : !spirv.struct<(f32, f32, f32, f32)>
    %cst1_i32 = spirv.Constant 1 : i32
    %5 = spirv.CompositeExtract %4[1 : i32] : !spirv.struct<(f32, f32, f32, f32)>
    %6 = spirv.Load "Function" %1 : !spirv.struct<(f32, f32, f32, f32)>
    %cst2_i32 = spirv.Constant 2 : i32
    %7 = spirv.CompositeExtract %6[2 : i32] : !spirv.struct<(f32, f32, f32, f32)>
    %8 = spirv.Load "Function" %1 : !spirv.struct<(f32, f32, f32, f32)>
    %cst3_i32 = spirv.Constant 3 : i32
    %9 = spirv.CompositeExtract %8[3 : i32] : !spirv.struct<(f32, f32, f32, f32)>
    %10 = spirv.CompositeConstruct %3, %5, %7, %9 : (f32, f32, f32, f32) -> vector<4xf32>
    spirv.Store "Output" %outColor_addr, %10 : vector<4xf32>
    spirv.Return
  }
  spirv.EntryPoint "Fragment" @main, @outColor
}
```
